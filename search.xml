<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react如何在组件外部调用组件内的方法]]></title>
    <url>%2F2018%2F07%2F04%2FreactTechnology%2F</url>
    <content type="text"><![CDATA[在开发中，难免会遇到这种场景：我们需要在组件外部调用组件内的方法，从而达到在外部操作组件或者获取组件内部数据的目的。示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import * as React from "react";//外层组件export class Parent extends React.Component&lt;&#123;&#125;, &#123;&#125;&gt; &#123; //用一个变量接收子组件的this public child: any; constructor() &#123; super(); &#125; //绑定子组件的this到this.child bindChild = (ref:any) =&gt; &#123; this.child = ref; &#125; //用于调用子组件的方法 click = (e) =&gt; &#123; this.child.myName() &#125; public render() &#123; return &lt;div&gt; &lt;Child bindChild=&#123;this.bindChild&#125; /&gt; &lt;button onClick=&#123;this.click&#125; &gt;getName&lt;/button&gt; &lt;/div&gt; &#125;&#125;//子组件interface ChildOwnProps &#123; bindChild: Function;//提供一个属性，用于把this传递给外部组件&#125;class Child extends React.Component&lt;ChildOwnProps&gt; &#123; constructor(props:ChildOwnProps) &#123; super(props); &#125; componentDidMount()&#123; //传递this this.props.bindChild(this); &#125; //供外部调用的方法 myName = () =&gt; alert('xiaohesong') render() &#123; return &lt;div&gt;child&lt;/div&gt; &#125;&#125; 其实原理很简单，即子组件向外提供一个属性，用于把自己的this传递给外部组件，外部组件用一个变量接收子组件传递过来的this之后就可以随意调用子组件内部的方法。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新cordova时出现的报错及解决方案]]></title>
    <url>%2F2018%2F06%2F08%2FcordovaUpdate%2F</url>
    <content type="text"><![CDATA[今天在利用cordova build安卓apk的时候出现了报错，并且提示更新cordova，于是执行以下命令做更新：1npm install -g cordova 结果出现了报错，如下1npm WARN update-linked node_modules\cordova needs updating to 8.0.0 from 6.4.0 but we can&apos;t, as it&apos;s a symlink 在网上查了半天也没找到原因，于是尝试了先去remove再install，结果成功了，如下12npm remove -g cordovanpm install -g cordova 至于报错的原因，还有待后面研究下…]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过url跳转到微信公众号关注页]]></title>
    <url>%2F2018%2F05%2F24%2FwechatFollow%2F</url>
    <content type="text"><![CDATA[微信端微信端实现相对比较简单，首先需要获取公众号关注页的url，步骤如下：1.点击公众号的历史消息2.复制链接3.接下来在微信里直接跳转这个链接即可1window.location.href="https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzAxNjU0MjEyNA==&amp;scene=123&amp;from=singlemessage&amp;isappinstalled=0#wechat_redirect" 手机QQ直接跳转这个链接即可唤起微信：1window.location.href = 'weixin://'; 但是不能在QQ里跳转微信的那个链接，如下图 平台的判断这里用的到是userAgent，代码如下123456let ua = navigator.userAgent.toLowerCase();if (ua.indexOf("micromessenger") &gt; 0) &#123; //微信端&#125; else if (ua.indexOf("qq") &gt; 0) &#123; //手机qq&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js promise简例及一些注意点]]></title>
    <url>%2F2018%2F05%2F11%2FjsPromise%2F</url>
    <content type="text"><![CDATA[无论promise中的执行结果是什么，它总会给你返回一个状态，成功或者失败1234567891011121314151617181920212223242526272829303132//封装promisefunction getURL(URL) &#123; return new Promise(function (resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;//执行var URL = "http:***";getURL(URL).then(function(value) &#123; console.log(value);&#125;).catch(function(error) &#123; console.error(error);&#125;);//也可以这样写//getURL(URL).then(function(value) &#123;// console.log(value);//&#125;, function(error)&#123;// console.error(error);//&#125;) 在angularjs中可以通过$q实现异步操作：通过调用 $q.defer() 可以构建一个新的 deffered 实例,deffered 对象用来将 Promise 实例与 标记任务状态(执行成功还是不成功)的 API 相关联，deffered 对象的方法 resolve(value) ——成功，如果 value 是一个通过 $q.reject 构造的拒绝对象(rejection) , 该promise 将被拒绝。 reject(reason) ——失败，这相当于通过 $q.reject构造的拒绝对象(rejection)作为参数传递给 resolve。 notify(value) ——在 promise 执行的过程中提供状态更新。 这在 promise 被解决或拒绝之前可能会被多次调用。 例子如下： 12345678910111213141516171819202122//封装promisefunction asyncGreet(name) &#123; var deferred = $q.defer(); setTimeout(function () &#123; deferred.notify('即将问候 ' + name + '.'); if (okToGreet(name)) &#123; deferred.resolve('你好, ' + name + '!'); &#125; else &#123; deferred.reject('拒绝问候 ' + name + ' .'); &#125; &#125;, 1000); return deferred.promise;&#125;//执行var promise = asyncGreet('***');promise.then(function (res) &#123;&#125;, function (error) &#123;&#125;, function (update) &#123;&#125;);]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180504随笔]]></title>
    <url>%2F2018%2F05%2F04%2F20180504Essay%2F</url>
    <content type="text"><![CDATA[3月份的时候了解到了Hexo，感觉还是挺有意思的，主要是很多东西需要自己折腾，而且比博客园要好看很多，就折腾了下； 其实很久都不更新博客了，3月至5月这个项目确实也没啥要记的，都是业务逻辑，也可能是自己越来越懒了，以后要养成好习惯，不论是知识点，难点还是开发中的报错，都要记录一下；得抓紧时间落实一下FD的事情；没事就练练车，提高下车技；]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React的Ref属性在TypeScript中的写法]]></title>
    <url>%2F2018%2F05%2F04%2FreactRefs%2F</url>
    <content type="text"><![CDATA[在TypeScript中使用ref属性的时候，如果不定义它的类型直接去使用this.refs.XXX，就会在编译的时候报错。参考如下代码： 1234567891011121314151617181920212223242526import * as React from "react";export class CustomTextInput extends React.Component&lt;&#123;&#125;, &#123;&#125;&gt; &#123; //在此处统一定义refs public refs: &#123; textInput: HTMLInputElement, loadMoreDiv: HTMLElement &#125;; constructor() &#123; super(); &#125; componentDidMount() &#123; const loadMore = this.refs.loadMoreDiv; const myInput = this.refs.textInput; &#125; public render() &#123; return &lt;div&gt; &lt;input type="text" ref= "textInput" /&gt; &lt;div ref= "loadMoreDiv"&gt;&lt;/div&gt; &lt;/div&gt;; &#125;&#125; 转自：Strongly Typed React Refs with TypeScript]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用小记]]></title>
    <url>%2F2018%2F05%2F04%2FHexo%2F</url>
    <content type="text"><![CDATA[1. 关于部署到github时用户名密码报错的问题刚开始部署的配置如下1234deploy: type: git repo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master 结果会报没有用户名密码的错误，大致如下12345fatal: could not read Username for &apos;GitHub · Where software is built&apos;: No errorFATAL Something&apos;s wrong. Maybe you can find the solution here: TroubleshootingError: bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;GitHub · Where software is built&apos;: No erro 解决办法为修改配置为如下：1234deploy: type: git repo: https://&#123;yourname&#125;:&#123;yourpassword&#125;@github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master 转自：有关使用 Hexo 和 GitHub 搭建博客，出现 hexo -d 报错如何解决？ 2. 配置文件一定要指明language 3. 集成disqus评论功能进入disqus官网，点击红色框中链接，给自己的网站添加disqus，如下图接着输入你的网址，选择类别，生成shortname拿到shortname，分别添加到站点配置文件的disqus_shortname和主题配置文件的disqus中的shortname，并且将主题配置文件disqus的enable设为true 4. 如何给文章的md文件中插入图片把站点配置文件的post_asset_folder设置为true； 接着执行命令，来自hexo-asset-image；1$ npm install hexo-asset-image --save 安装好之后，在用hexo n xxx创建新文档的时候，/source/_posts文件夹内除了xxx.md文件还会有一个同名的文件夹，这个文件夹就是用来存放图片的； 最后在xxx.md中想引入图片时先，先把图片复制到xxx文件夹中，接下来直接在xxx.md中按照markdown的格式引入图片：![你想输入的替代文字](xxxx/图片名.jpg)即可 转自：hexo生成博文插入图片 5. 设置阅读全文根据文章的内容，自己在合适的位置添加 &lt;!–more–&gt;标签，使用灵活，也是Hexo推荐的方法 6. 使用local_search为站点增加搜索功能安装 hexo-generator-search，在站点的根目录下执行以下命令：1$ npm install hexo-generator-search --save 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件中local_search的enable为true即可 转自：hexo博客添加搜索功能 持续补充中。。。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
